// Code generated by pggen. DO NOT EDIT.

package pggen

import (
	"context"
	"fmt"
	"time"

	"github.com/jackc/pgconn"
	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

const insertPlanSQL = `INSERT INTO plans (
    plan_id,
    run_id,
    status
) VALUES (
    $1,
    $2,
    $3
);`

type InsertPlanParams struct {
	PlanID pgtype.Text
	RunID  pgtype.Text
	Status pgtype.Text
}

// InsertPlan implements Querier.InsertPlan.
func (q *DBQuerier) InsertPlan(ctx context.Context, params InsertPlanParams) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertPlan")
	cmdTag, err := q.conn.Exec(ctx, insertPlanSQL, params.PlanID, params.RunID, params.Status)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query InsertPlan: %w", err)
	}
	return cmdTag, err
}

// InsertPlanBatch implements Querier.InsertPlanBatch.
func (q *DBQuerier) InsertPlanBatch(batch genericBatch, params InsertPlanParams) {
	batch.Queue(insertPlanSQL, params.PlanID, params.RunID, params.Status)
}

// InsertPlanScan implements Querier.InsertPlanScan.
func (q *DBQuerier) InsertPlanScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec InsertPlanBatch: %w", err)
	}
	return cmdTag, err
}

const insertPlanStatusTimestampSQL = `INSERT INTO plan_status_timestamps (
    plan_id,
    status,
    timestamp
) VALUES (
    $1,
    $2,
    $3
);`

type InsertPlanStatusTimestampParams struct {
	PlanID    pgtype.Text
	Status    pgtype.Text
	Timestamp time.Time
}

// InsertPlanStatusTimestamp implements Querier.InsertPlanStatusTimestamp.
func (q *DBQuerier) InsertPlanStatusTimestamp(ctx context.Context, params InsertPlanStatusTimestampParams) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertPlanStatusTimestamp")
	cmdTag, err := q.conn.Exec(ctx, insertPlanStatusTimestampSQL, params.PlanID, params.Status, params.Timestamp)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query InsertPlanStatusTimestamp: %w", err)
	}
	return cmdTag, err
}

// InsertPlanStatusTimestampBatch implements Querier.InsertPlanStatusTimestampBatch.
func (q *DBQuerier) InsertPlanStatusTimestampBatch(batch genericBatch, params InsertPlanStatusTimestampParams) {
	batch.Queue(insertPlanStatusTimestampSQL, params.PlanID, params.Status, params.Timestamp)
}

// InsertPlanStatusTimestampScan implements Querier.InsertPlanStatusTimestampScan.
func (q *DBQuerier) InsertPlanStatusTimestampScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec InsertPlanStatusTimestampBatch: %w", err)
	}
	return cmdTag, err
}

const updatePlanStatusByIDSQL = `UPDATE plans
SET status = $1
WHERE plan_id = $2
RETURNING plan_id
;`

// UpdatePlanStatusByID implements Querier.UpdatePlanStatusByID.
func (q *DBQuerier) UpdatePlanStatusByID(ctx context.Context, status pgtype.Text, planID pgtype.Text) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdatePlanStatusByID")
	row := q.conn.QueryRow(ctx, updatePlanStatusByIDSQL, status, planID)
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query UpdatePlanStatusByID: %w", err)
	}
	return item, nil
}

// UpdatePlanStatusByIDBatch implements Querier.UpdatePlanStatusByIDBatch.
func (q *DBQuerier) UpdatePlanStatusByIDBatch(batch genericBatch, status pgtype.Text, planID pgtype.Text) {
	batch.Queue(updatePlanStatusByIDSQL, status, planID)
}

// UpdatePlanStatusByIDScan implements Querier.UpdatePlanStatusByIDScan.
func (q *DBQuerier) UpdatePlanStatusByIDScan(results pgx.BatchResults) (pgtype.Text, error) {
	row := results.QueryRow()
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan UpdatePlanStatusByIDBatch row: %w", err)
	}
	return item, nil
}

const updatePlannedChangesByIDSQL = `UPDATE plans
SET report = (
    $1,
    $2,
    $3
)
WHERE plan_id = $4
RETURNING plan_id
;`

type UpdatePlannedChangesByIDParams struct {
	Additions    int
	Changes      int
	Destructions int
	PlanID       pgtype.Text
}

// UpdatePlannedChangesByID implements Querier.UpdatePlannedChangesByID.
func (q *DBQuerier) UpdatePlannedChangesByID(ctx context.Context, params UpdatePlannedChangesByIDParams) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdatePlannedChangesByID")
	row := q.conn.QueryRow(ctx, updatePlannedChangesByIDSQL, params.Additions, params.Changes, params.Destructions, params.PlanID)
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query UpdatePlannedChangesByID: %w", err)
	}
	return item, nil
}

// UpdatePlannedChangesByIDBatch implements Querier.UpdatePlannedChangesByIDBatch.
func (q *DBQuerier) UpdatePlannedChangesByIDBatch(batch genericBatch, params UpdatePlannedChangesByIDParams) {
	batch.Queue(updatePlannedChangesByIDSQL, params.Additions, params.Changes, params.Destructions, params.PlanID)
}

// UpdatePlannedChangesByIDScan implements Querier.UpdatePlannedChangesByIDScan.
func (q *DBQuerier) UpdatePlannedChangesByIDScan(results pgx.BatchResults) (pgtype.Text, error) {
	row := results.QueryRow()
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan UpdatePlannedChangesByIDBatch row: %w", err)
	}
	return item, nil
}

const findRunIDByPlanIDSQL = `SELECT run_id
FROM plans
WHERE plan_id = $1
;`

// FindRunIDByPlanID implements Querier.FindRunIDByPlanID.
func (q *DBQuerier) FindRunIDByPlanID(ctx context.Context, planID pgtype.Text) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindRunIDByPlanID")
	row := q.conn.QueryRow(ctx, findRunIDByPlanIDSQL, planID)
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query FindRunIDByPlanID: %w", err)
	}
	return item, nil
}

// FindRunIDByPlanIDBatch implements Querier.FindRunIDByPlanIDBatch.
func (q *DBQuerier) FindRunIDByPlanIDBatch(batch genericBatch, planID pgtype.Text) {
	batch.Queue(findRunIDByPlanIDSQL, planID)
}

// FindRunIDByPlanIDScan implements Querier.FindRunIDByPlanIDScan.
func (q *DBQuerier) FindRunIDByPlanIDScan(results pgx.BatchResults) (pgtype.Text, error) {
	row := results.QueryRow()
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan FindRunIDByPlanIDBatch row: %w", err)
	}
	return item, nil
}

const getPlanBinByIDSQL = `SELECT plan_bin
FROM plans
WHERE plan_id = $1
;`

// GetPlanBinByID implements Querier.GetPlanBinByID.
func (q *DBQuerier) GetPlanBinByID(ctx context.Context, planID pgtype.Text) ([]byte, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "GetPlanBinByID")
	row := q.conn.QueryRow(ctx, getPlanBinByIDSQL, planID)
	item := []byte{}
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query GetPlanBinByID: %w", err)
	}
	return item, nil
}

// GetPlanBinByIDBatch implements Querier.GetPlanBinByIDBatch.
func (q *DBQuerier) GetPlanBinByIDBatch(batch genericBatch, planID pgtype.Text) {
	batch.Queue(getPlanBinByIDSQL, planID)
}

// GetPlanBinByIDScan implements Querier.GetPlanBinByIDScan.
func (q *DBQuerier) GetPlanBinByIDScan(results pgx.BatchResults) ([]byte, error) {
	row := results.QueryRow()
	item := []byte{}
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan GetPlanBinByIDBatch row: %w", err)
	}
	return item, nil
}

const getPlanJSONByIDSQL = `SELECT plan_json
FROM plans
WHERE plan_id = $1
;`

// GetPlanJSONByID implements Querier.GetPlanJSONByID.
func (q *DBQuerier) GetPlanJSONByID(ctx context.Context, planID pgtype.Text) ([]byte, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "GetPlanJSONByID")
	row := q.conn.QueryRow(ctx, getPlanJSONByIDSQL, planID)
	item := []byte{}
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query GetPlanJSONByID: %w", err)
	}
	return item, nil
}

// GetPlanJSONByIDBatch implements Querier.GetPlanJSONByIDBatch.
func (q *DBQuerier) GetPlanJSONByIDBatch(batch genericBatch, planID pgtype.Text) {
	batch.Queue(getPlanJSONByIDSQL, planID)
}

// GetPlanJSONByIDScan implements Querier.GetPlanJSONByIDScan.
func (q *DBQuerier) GetPlanJSONByIDScan(results pgx.BatchResults) ([]byte, error) {
	row := results.QueryRow()
	item := []byte{}
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan GetPlanJSONByIDBatch row: %w", err)
	}
	return item, nil
}

const updatePlanBinByIDSQL = `UPDATE plans
SET plan_bin = $1
WHERE plan_id = $2
RETURNING plan_id
;`

// UpdatePlanBinByID implements Querier.UpdatePlanBinByID.
func (q *DBQuerier) UpdatePlanBinByID(ctx context.Context, planBin []byte, planID pgtype.Text) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdatePlanBinByID")
	row := q.conn.QueryRow(ctx, updatePlanBinByIDSQL, planBin, planID)
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query UpdatePlanBinByID: %w", err)
	}
	return item, nil
}

// UpdatePlanBinByIDBatch implements Querier.UpdatePlanBinByIDBatch.
func (q *DBQuerier) UpdatePlanBinByIDBatch(batch genericBatch, planBin []byte, planID pgtype.Text) {
	batch.Queue(updatePlanBinByIDSQL, planBin, planID)
}

// UpdatePlanBinByIDScan implements Querier.UpdatePlanBinByIDScan.
func (q *DBQuerier) UpdatePlanBinByIDScan(results pgx.BatchResults) (pgtype.Text, error) {
	row := results.QueryRow()
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan UpdatePlanBinByIDBatch row: %w", err)
	}
	return item, nil
}

const updatePlanJSONByIDSQL = `UPDATE plans
SET plan_json = $1
WHERE plan_id = $2
RETURNING plan_id
;`

// UpdatePlanJSONByID implements Querier.UpdatePlanJSONByID.
func (q *DBQuerier) UpdatePlanJSONByID(ctx context.Context, planJSON []byte, planID pgtype.Text) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdatePlanJSONByID")
	row := q.conn.QueryRow(ctx, updatePlanJSONByIDSQL, planJSON, planID)
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query UpdatePlanJSONByID: %w", err)
	}
	return item, nil
}

// UpdatePlanJSONByIDBatch implements Querier.UpdatePlanJSONByIDBatch.
func (q *DBQuerier) UpdatePlanJSONByIDBatch(batch genericBatch, planJSON []byte, planID pgtype.Text) {
	batch.Queue(updatePlanJSONByIDSQL, planJSON, planID)
}

// UpdatePlanJSONByIDScan implements Querier.UpdatePlanJSONByIDScan.
func (q *DBQuerier) UpdatePlanJSONByIDScan(results pgx.BatchResults) (pgtype.Text, error) {
	row := results.QueryRow()
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan UpdatePlanJSONByIDBatch row: %w", err)
	}
	return item, nil
}

const insertPlanLogChunkSQL = `INSERT INTO plan_logs (
    plan_id,
    chunk
) VALUES (
    $1,
    $2
)
;`

// InsertPlanLogChunk implements Querier.InsertPlanLogChunk.
func (q *DBQuerier) InsertPlanLogChunk(ctx context.Context, planID pgtype.Text, chunk []byte) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertPlanLogChunk")
	cmdTag, err := q.conn.Exec(ctx, insertPlanLogChunkSQL, planID, chunk)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query InsertPlanLogChunk: %w", err)
	}
	return cmdTag, err
}

// InsertPlanLogChunkBatch implements Querier.InsertPlanLogChunkBatch.
func (q *DBQuerier) InsertPlanLogChunkBatch(batch genericBatch, planID pgtype.Text, chunk []byte) {
	batch.Queue(insertPlanLogChunkSQL, planID, chunk)
}

// InsertPlanLogChunkScan implements Querier.InsertPlanLogChunkScan.
func (q *DBQuerier) InsertPlanLogChunkScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec InsertPlanLogChunkBatch: %w", err)
	}
	return cmdTag, err
}

const findPlanLogChunksSQL = `SELECT
    substring(string_agg(chunk, '') FROM $1 FOR $2)
FROM (
    SELECT plan_id, chunk
    FROM plan_logs
    WHERE plan_id = $3
    ORDER BY chunk_id
) c
GROUP BY plan_id
;`

type FindPlanLogChunksParams struct {
	Offset int
	Limit  int
	PlanID pgtype.Text
}

// FindPlanLogChunks implements Querier.FindPlanLogChunks.
func (q *DBQuerier) FindPlanLogChunks(ctx context.Context, params FindPlanLogChunksParams) ([]byte, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindPlanLogChunks")
	row := q.conn.QueryRow(ctx, findPlanLogChunksSQL, params.Offset, params.Limit, params.PlanID)
	item := []byte{}
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query FindPlanLogChunks: %w", err)
	}
	return item, nil
}

// FindPlanLogChunksBatch implements Querier.FindPlanLogChunksBatch.
func (q *DBQuerier) FindPlanLogChunksBatch(batch genericBatch, params FindPlanLogChunksParams) {
	batch.Queue(findPlanLogChunksSQL, params.Offset, params.Limit, params.PlanID)
}

// FindPlanLogChunksScan implements Querier.FindPlanLogChunksScan.
func (q *DBQuerier) FindPlanLogChunksScan(results pgx.BatchResults) ([]byte, error) {
	row := results.QueryRow()
	item := []byte{}
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan FindPlanLogChunksBatch row: %w", err)
	}
	return item, nil
}
