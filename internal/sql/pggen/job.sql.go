// Code generated by pggen. DO NOT EDIT.

package pggen

import (
	"context"
	"fmt"

	"github.com/jackc/pgconn"
	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

const insertJobSQL = `INSERT INTO jobs (
    job_id,
    run_id,
    phase,
    agent_id,
    status
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5
);`

type InsertJobParams struct {
	JobID   pgtype.Text
	RunID   pgtype.Text
	Phase   pgtype.Text
	AgentID pgtype.Text
	Status  pgtype.Text
}

// InsertJob implements Querier.InsertJob.
func (q *DBQuerier) InsertJob(ctx context.Context, params InsertJobParams) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertJob")
	cmdTag, err := q.conn.Exec(ctx, insertJobSQL, params.JobID, params.RunID, params.Phase, params.AgentID, params.Status)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query InsertJob: %w", err)
	}
	return cmdTag, err
}

// InsertJobBatch implements Querier.InsertJobBatch.
func (q *DBQuerier) InsertJobBatch(batch genericBatch, params InsertJobParams) {
	batch.Queue(insertJobSQL, params.JobID, params.RunID, params.Phase, params.AgentID, params.Status)
}

// InsertJobScan implements Querier.InsertJobScan.
func (q *DBQuerier) InsertJobScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec InsertJobBatch: %w", err)
	}
	return cmdTag, err
}

const assignJobSQL = `UPDATE jobs
SET
    status = $1,
    agent_id = $2
WHERE job_id = $3
RETURNING status
;`

type AssignJobParams struct {
	Status  pgtype.Text
	AgentID pgtype.Text
	JobID   pgtype.Text
}

// AssignJob implements Querier.AssignJob.
func (q *DBQuerier) AssignJob(ctx context.Context, params AssignJobParams) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "AssignJob")
	row := q.conn.QueryRow(ctx, assignJobSQL, params.Status, params.AgentID, params.JobID)
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query AssignJob: %w", err)
	}
	return item, nil
}

// AssignJobBatch implements Querier.AssignJobBatch.
func (q *DBQuerier) AssignJobBatch(batch genericBatch, params AssignJobParams) {
	batch.Queue(assignJobSQL, params.Status, params.AgentID, params.JobID)
}

// AssignJobScan implements Querier.AssignJobScan.
func (q *DBQuerier) AssignJobScan(results pgx.BatchResults) (pgtype.Text, error) {
	row := results.QueryRow()
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan AssignJobBatch row: %w", err)
	}
	return item, nil
}

const updateJobStatusSQL = `UPDATE jobs
SET
    status = $1
WHERE job_id = $2
RETURNING status
;`

// UpdateJobStatus implements Querier.UpdateJobStatus.
func (q *DBQuerier) UpdateJobStatus(ctx context.Context, status pgtype.Text, jobID pgtype.Text) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateJobStatus")
	row := q.conn.QueryRow(ctx, updateJobStatusSQL, status, jobID)
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query UpdateJobStatus: %w", err)
	}
	return item, nil
}

// UpdateJobStatusBatch implements Querier.UpdateJobStatusBatch.
func (q *DBQuerier) UpdateJobStatusBatch(batch genericBatch, status pgtype.Text, jobID pgtype.Text) {
	batch.Queue(updateJobStatusSQL, status, jobID)
}

// UpdateJobStatusScan implements Querier.UpdateJobStatusScan.
func (q *DBQuerier) UpdateJobStatusScan(results pgx.BatchResults) (pgtype.Text, error) {
	row := results.QueryRow()
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan UpdateJobStatusBatch row: %w", err)
	}
	return item, nil
}

const findAssignedJobByAgentIDSQL = `SELECT *
FROM jobs
WHERE status = 'assigned'
AND   agent_id = $1
;`

type FindAssignedJobByAgentIDRow struct {
	JobID   pgtype.Text `json:"job_id"`
	RunID   pgtype.Text `json:"run_id"`
	Phase   pgtype.Text `json:"phase"`
	AgentID pgtype.Text `json:"agent_id"`
	Status  pgtype.Text `json:"status"`
}

// FindAssignedJobByAgentID implements Querier.FindAssignedJobByAgentID.
func (q *DBQuerier) FindAssignedJobByAgentID(ctx context.Context, agentID pgtype.Text) (FindAssignedJobByAgentIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindAssignedJobByAgentID")
	row := q.conn.QueryRow(ctx, findAssignedJobByAgentIDSQL, agentID)
	var item FindAssignedJobByAgentIDRow
	if err := row.Scan(&item.JobID, &item.RunID, &item.Phase, &item.AgentID, &item.Status); err != nil {
		return item, fmt.Errorf("query FindAssignedJobByAgentID: %w", err)
	}
	return item, nil
}

// FindAssignedJobByAgentIDBatch implements Querier.FindAssignedJobByAgentIDBatch.
func (q *DBQuerier) FindAssignedJobByAgentIDBatch(batch genericBatch, agentID pgtype.Text) {
	batch.Queue(findAssignedJobByAgentIDSQL, agentID)
}

// FindAssignedJobByAgentIDScan implements Querier.FindAssignedJobByAgentIDScan.
func (q *DBQuerier) FindAssignedJobByAgentIDScan(results pgx.BatchResults) (FindAssignedJobByAgentIDRow, error) {
	row := results.QueryRow()
	var item FindAssignedJobByAgentIDRow
	if err := row.Scan(&item.JobID, &item.RunID, &item.Phase, &item.AgentID, &item.Status); err != nil {
		return item, fmt.Errorf("scan FindAssignedJobByAgentIDBatch row: %w", err)
	}
	return item, nil
}

const findJobByRunIDAndPhaseSQL = `SELECT *
FROM jobs
WHERE run_id = $1
AND   phase = $2
;`

type FindJobByRunIDAndPhaseRow struct {
	JobID   pgtype.Text `json:"job_id"`
	RunID   pgtype.Text `json:"run_id"`
	Phase   pgtype.Text `json:"phase"`
	AgentID pgtype.Text `json:"agent_id"`
	Status  pgtype.Text `json:"status"`
}

// FindJobByRunIDAndPhase implements Querier.FindJobByRunIDAndPhase.
func (q *DBQuerier) FindJobByRunIDAndPhase(ctx context.Context, runID pgtype.Text, phase pgtype.Text) (FindJobByRunIDAndPhaseRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindJobByRunIDAndPhase")
	row := q.conn.QueryRow(ctx, findJobByRunIDAndPhaseSQL, runID, phase)
	var item FindJobByRunIDAndPhaseRow
	if err := row.Scan(&item.JobID, &item.RunID, &item.Phase, &item.AgentID, &item.Status); err != nil {
		return item, fmt.Errorf("query FindJobByRunIDAndPhase: %w", err)
	}
	return item, nil
}

// FindJobByRunIDAndPhaseBatch implements Querier.FindJobByRunIDAndPhaseBatch.
func (q *DBQuerier) FindJobByRunIDAndPhaseBatch(batch genericBatch, runID pgtype.Text, phase pgtype.Text) {
	batch.Queue(findJobByRunIDAndPhaseSQL, runID, phase)
}

// FindJobByRunIDAndPhaseScan implements Querier.FindJobByRunIDAndPhaseScan.
func (q *DBQuerier) FindJobByRunIDAndPhaseScan(results pgx.BatchResults) (FindJobByRunIDAndPhaseRow, error) {
	row := results.QueryRow()
	var item FindJobByRunIDAndPhaseRow
	if err := row.Scan(&item.JobID, &item.RunID, &item.Phase, &item.AgentID, &item.Status); err != nil {
		return item, fmt.Errorf("scan FindJobByRunIDAndPhaseBatch row: %w", err)
	}
	return item, nil
}
