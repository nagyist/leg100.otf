// Code generated by pggen. DO NOT EDIT.

package pggen

import (
	"context"
	"fmt"

	"github.com/jackc/pgconn"
	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

const insertJobSQL = `INSERT INTO jobs (
    job_id,
    run_id,
    phase,
    agent_id,
    status
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5
);`

type InsertJobParams struct {
	JobID   pgtype.Text
	RunID   pgtype.Text
	Phase   pgtype.Text
	AgentID pgtype.Text
	Status  pgtype.Text
}

// InsertJob implements Querier.InsertJob.
func (q *DBQuerier) InsertJob(ctx context.Context, params InsertJobParams) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertJob")
	cmdTag, err := q.conn.Exec(ctx, insertJobSQL, params.JobID, params.RunID, params.Phase, params.AgentID, params.Status)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query InsertJob: %w", err)
	}
	return cmdTag, err
}

// InsertJobBatch implements Querier.InsertJobBatch.
func (q *DBQuerier) InsertJobBatch(batch genericBatch, params InsertJobParams) {
	batch.Queue(insertJobSQL, params.JobID, params.RunID, params.Phase, params.AgentID, params.Status)
}

// InsertJobScan implements Querier.InsertJobScan.
func (q *DBQuerier) InsertJobScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec InsertJobBatch: %w", err)
	}
	return cmdTag, err
}

const assignJobSQL = `UPDATE jobs
SET
    status = $1,
    agent_id = $2
WHERE job_id = $3
RETURNING status
;`

type AssignJobParams struct {
	Status  pgtype.Text
	AgentID pgtype.Text
	JobID   pgtype.Text
}

// AssignJob implements Querier.AssignJob.
func (q *DBQuerier) AssignJob(ctx context.Context, params AssignJobParams) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "AssignJob")
	row := q.conn.QueryRow(ctx, assignJobSQL, params.Status, params.AgentID, params.JobID)
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query AssignJob: %w", err)
	}
	return item, nil
}

// AssignJobBatch implements Querier.AssignJobBatch.
func (q *DBQuerier) AssignJobBatch(batch genericBatch, params AssignJobParams) {
	batch.Queue(assignJobSQL, params.Status, params.AgentID, params.JobID)
}

// AssignJobScan implements Querier.AssignJobScan.
func (q *DBQuerier) AssignJobScan(results pgx.BatchResults) (pgtype.Text, error) {
	row := results.QueryRow()
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan AssignJobBatch row: %w", err)
	}
	return item, nil
}

const updateJobStatusSQL = `UPDATE jobs
SET
    status = $1
WHERE job_id = $2
RETURNING status
;`

// UpdateJobStatus implements Querier.UpdateJobStatus.
func (q *DBQuerier) UpdateJobStatus(ctx context.Context, status pgtype.Text, jobID pgtype.Text) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateJobStatus")
	row := q.conn.QueryRow(ctx, updateJobStatusSQL, status, jobID)
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query UpdateJobStatus: %w", err)
	}
	return item, nil
}

// UpdateJobStatusBatch implements Querier.UpdateJobStatusBatch.
func (q *DBQuerier) UpdateJobStatusBatch(batch genericBatch, status pgtype.Text, jobID pgtype.Text) {
	batch.Queue(updateJobStatusSQL, status, jobID)
}

// UpdateJobStatusScan implements Querier.UpdateJobStatusScan.
func (q *DBQuerier) UpdateJobStatusScan(results pgx.BatchResults) (pgtype.Text, error) {
	row := results.QueryRow()
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan UpdateJobStatusBatch row: %w", err)
	}
	return item, nil
}

const findJobsByStatusSQL = `SELECT *
FROM jobs
WHERE status = $1
;`

type FindJobsByStatusRow struct {
	JobID   pgtype.Text `json:"job_id"`
	RunID   pgtype.Text `json:"run_id"`
	Phase   pgtype.Text `json:"phase"`
	AgentID pgtype.Text `json:"agent_id"`
	Status  pgtype.Text `json:"status"`
}

// FindJobsByStatus implements Querier.FindJobsByStatus.
func (q *DBQuerier) FindJobsByStatus(ctx context.Context, status pgtype.Text) ([]FindJobsByStatusRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindJobsByStatus")
	rows, err := q.conn.Query(ctx, findJobsByStatusSQL, status)
	if err != nil {
		return nil, fmt.Errorf("query FindJobsByStatus: %w", err)
	}
	defer rows.Close()
	items := []FindJobsByStatusRow{}
	for rows.Next() {
		var item FindJobsByStatusRow
		if err := rows.Scan(&item.JobID, &item.RunID, &item.Phase, &item.AgentID, &item.Status); err != nil {
			return nil, fmt.Errorf("scan FindJobsByStatus row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindJobsByStatus rows: %w", err)
	}
	return items, err
}

// FindJobsByStatusBatch implements Querier.FindJobsByStatusBatch.
func (q *DBQuerier) FindJobsByStatusBatch(batch genericBatch, status pgtype.Text) {
	batch.Queue(findJobsByStatusSQL, status)
}

// FindJobsByStatusScan implements Querier.FindJobsByStatusScan.
func (q *DBQuerier) FindJobsByStatusScan(results pgx.BatchResults) ([]FindJobsByStatusRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query FindJobsByStatusBatch: %w", err)
	}
	defer rows.Close()
	items := []FindJobsByStatusRow{}
	for rows.Next() {
		var item FindJobsByStatusRow
		if err := rows.Scan(&item.JobID, &item.RunID, &item.Phase, &item.AgentID, &item.Status); err != nil {
			return nil, fmt.Errorf("scan FindJobsByStatusBatch row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindJobsByStatusBatch rows: %w", err)
	}
	return items, err
}
