{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>OTF is an open-source alternative to Terraform Enterprise, sharing many of its features:</p> <ul> <li>Full Terraform CLI integration</li> <li>Remote execution mode: plans and applies run on servers</li> <li>Agent execution mode: plans and applies run on agents</li> <li>Remote state backend: state stored in PostgreSQL</li> <li>SSO: sign in using an identity provider, e.g. Github, Gitlab etc.</li> <li>Module registry (provider registry coming soon)</li> <li>RBAC: control team access to workspaces</li> <li>VCS integration: trigger runs and publish modules from git commits</li> <li>Compatible with much of the Terraform Enterprise/Cloud API</li> <li>Minimal dependencies: requires only PostgreSQL</li> <li>Stateless: horizontally scale servers in pods on Kubernetes, etc</li> </ul> <p>Feel free to trial it using the demo deployment: https://demo.otf.ninja</p>"},{"location":"agents/","title":"Agents","text":"<p>OTF agents are dedicated processes for executing runs. They are functionally equivalent to Terraform Cloud Agents.</p> <p>The <code>otf-agent</code> process maintains an outbound connection to the otf server; no inbound connectivity is required. This makes it suited to deployment in parts of your network that are segregated. For example, you may have a kubernetes cluster for which connectivity is only possible within a local subnet. By deploying an agent to the subnet, terraform can connect to the cluster and provision kubernetes resources.</p> <p>Note</p> <p>An agent only handles runs for a single organization.</p>"},{"location":"agents/#setup-agent","title":"Setup agent","text":"<ul> <li>Log into the web app.</li> <li>Select an organization. This will be the organization that the agent handles runs on behalf of.</li> <li>Ensure you are on the main menu for the organization.</li> <li>Select <code>agent tokens</code>.</li> <li>Click <code>New Agent Token</code>.</li> <li>Provide a description for the token.</li> <li>Click the <code>Create token</code>.</li> <li>Copy the token to your clipboard (clicking on the token should do this).</li> <li>Start the agent in your terminal:</li> </ul> <pre><code>otf-agent --token &lt;the-token-string&gt; --address &lt;otf-server-hostname&gt;\n</code></pre> <ul> <li>The agent will confirm it has successfully authenticated:</li> </ul> <pre><code>2022-10-30T09:15:30Z INF successfully authenticated organization=automatize\n</code></pre>"},{"location":"agents/#configure-workspace","title":"Configure workspace","text":"<ul> <li>Login into the web app</li> <li>Select the organization in which you created an agent</li> <li>Ensure you are on the main menu for the organization.</li> <li>Select <code>workspaces</code>.</li> <li>Select a workspace.</li> <li>Click <code>settings</code> in the top right menu.</li> <li>Set <code>execution mode</code> to <code>agent</code></li> <li>Click <code>save changes</code>.</li> </ul> <p>Now runs for that workspace will be handled by an agent.</p>"},{"location":"cli/","title":"CLI","text":"<p><code>otf</code> is the CLI for OTF.</p> <p>Download a release. Ensure you select the client component, <code>otf</code>. The release is a zip file. Extract the <code>otf</code> binary to a directory in your system PATH.</p> <p>Run <code>otf</code> with no arguments to receive usage instructions:</p> <pre><code>Usage:\n  otf [command]\n\nAvailable Commands:\n  agents        Agent management\n  help          Help about any command\n  organizations Organization management\n  runs          Runs management\n  state         State version management\n  teams         Team management\n  users         User account management\n  workspaces    Workspace management\n\nFlags:\n      --address string   Address of OTF server (default \"localhost:8080\")\n  -h, --help             help for otf\n      --token string     API authentication token\n\nUse \"otf [command] --help\" for more information about a command.\n</code></pre> <p>Credentials are sourced from the same file the terraform CLI uses (<code>~/.terraform.d/credentials.tfrc.json</code>). To populate credentials, run:</p> <pre><code>terraform login &lt;otfd_hostname&gt;\n</code></pre> <p>Note</p> <p><code>terraform login</code> has a bug wherein it ignores the port when opening a browser. If you have included a port, e.g. <code>localhost:8080</code>, then you'll need to fix the URL in the browser address bar accordingly.</p>"},{"location":"dev/","title":"Development","text":"<p>Code contributions are welcome.</p>"},{"location":"dev/#setup-your-machine","title":"Setup your machine","text":"<ul> <li>Clone the repo:</li> </ul> <pre><code>git clone git@github.com:leg100/otf.git\n</code></pre> <ul> <li>Install Go.</li> <li>Install PostgreSQL (optional).</li> </ul>"},{"location":"dev/#tests","title":"Tests","text":""},{"location":"dev/#unit-tests","title":"Unit tests","text":"<p>Change into the repo directory and run unit tests:</p> <pre><code>go test ./...\n</code></pre>"},{"location":"dev/#integration-tests","title":"Integration tests","text":"<p>Integration tests require:</p> <ul> <li>PostgreSQL</li> <li>Terraform &gt;= 1.2.0</li> <li>Chrome</li> </ul> <p>Set the environment variable <code>OTF_TEST_DATABASE_URL</code> to a valid connection string. For example, if you have installed postgres on your local machine with the default database <code>postgres</code>:</p> <pre><code>export OTF_TEST_DATABASE_URL=postgres:///postgres\n</code></pre> <p>Then run the both unit and integration tests:</p> <pre><code>go test ./...\n</code></pre> <p>Note</p> <p>Tests check for the presence of <code>OTF_TEST_DATABASE_URL</code>. If it absent then only unit tests are run; otherwise both unit and integration tests are run.</p>"},{"location":"dev/#postgres-too-many-connections-error","title":"Postgres too many connections error","text":"<p>When running integration tests you may run into this error:</p> <pre><code>FATAL: sorry, too many clients already\n</code></pre> <p>The tests make potentially hundreds of connections to postgres at a time and you'll need to increase the maximum number of connections in postgres. Increase the <code>max_connections</code> parameter on your installation:</p> <pre><code>psql postgres:///otf\nalter system set max_connections = 999;\n</code></pre> <p>Then reload/restart postgres. On Ubuntu, for example:</p> <pre><code>sudo systemctl reload postgres\n</code></pre> <p>Note</p> <p>This is only recommended for a postgres installation dedicated to development and testing purposes. Too many connections in production most likely indicates a problem with the client application.</p>"},{"location":"dev/#postgres-performance-optimisation","title":"Postgres performance optimisation","text":"<p>To further improve the speed of your integration tests turn off <code>fsync</code>:</p> <pre><code>psql postgres:///otf\nalter system set fsync = off;\n</code></pre> <p>Then reload/restart postgres. On Ubuntu, for example:</p> <pre><code>sudo systemctl reload postgres\n</code></pre> <p>Note</p> <p>This is only recommended for a postgres installation dedicated to development and testing purposes. Disabling <code>fsync</code> can lead to data loss.</p>"},{"location":"dev/#database-cleanup","title":"Database cleanup","text":"<p>A dedicated logical database is created in postgres for each individual integration test; as a result the above command creates 100s of databases. Upon test completion the databases are removed. In certain situtations upon a test failure the test may fail to remove a database, in which case you will have to manually remove the database (although this is often not a concern other than consuming a small amount of disk space).</p>"},{"location":"dev/#disable-headless-mode","title":"Disable headless mode","text":"<p>Browser-based tests spawn a headless Chrome process. In certain situations it can be useful to disable headless mode, e.g. if a test is stuck on a certain page and you want to know which page. To disable headless mode:</p> <pre><code>export OTF_E2E_HEADLESS=false\n</code></pre>"},{"location":"dev/#cache-provider-requests","title":"Cache provider requests","text":"<p>Terraform-based tests spawn <code>terraform</code>. These tests retrieve providers from the internet which can consume quite a lot of bandwidth and slow down the tests significantly. To cache these providers it is recommended to use a caching proxy. The following make task runs squid in a docker container:</p> <pre><code>make squid\n</code></pre> <p>It is configured to use SSL-bumping, which permits caching content transported via SSL (<code>terraform</code> retrieves providers only via SSL).</p> <p>You then need to instruct the tests to use the proxy:</p> <pre><code>export HTTPS_PROXY=localhost:3128\n</code></pre> <p>You should now find the tests consume a lot less bandwidth and run several times faster.</p>"},{"location":"dev/#go-tfe-tests","title":"go-tfe tests","text":"<p>Tests from the go-tfe project are invoked to test adherence to the documented Terraform Cloud API. A subset of the tests are invoked from a fork using the following make task:</p> <ul> <li><code>make go-tfe-tests</code></li> </ul> <p>It requires postgres and otfd to be running, both of which can be started using docker compose:</p> <ul> <li><code>docker compose up -d</code></li> </ul>"},{"location":"dev/#sql-migrations","title":"SQL migrations","text":"<p>The database schema is migrated using goose. The SQL migration files are kept in the repo in <code>./sql/migrations</code>. Upon startup <code>otfd</code> automatically migrates the DB to the latest version.</p> <p>If you're developing a SQL migration you may want to migrate the database manually. Use the <code>make</code> tasks to assist you:</p> <ul> <li><code>make migrate</code></li> <li><code>make migrate-redo</code></li> <li><code>make migrate-rollback</code></li> <li><code>make migrate-status</code></li> </ul>"},{"location":"dev/#sql-queries","title":"SQL queries","text":"<p>SQL queries are handwritten in <code>./sql/queries</code> and turned into Go using pggen.</p> <p>After you make changes to the queries run the following make task to invoke <code>pggen</code>:</p> <ul> <li><code>make sql</code></li> </ul>"},{"location":"dev/#html-path-helpers","title":"HTML path helpers","text":"<p>Rails-style path helpers are generated using <code>go generate</code>. The path specifications are maintaining in <code>./http/html/paths/gen.go</code>. After making changes to the specs run the following make task to generate the helpers:</p> <ul> <li><code>make paths</code></li> </ul>"},{"location":"install/","title":"Installation","text":""},{"location":"install/#requirements","title":"Requirements","text":"<ul> <li>Linux - the server and agent components are tested on Linux only; the client CLI is not tested on other platforms but should work.</li> <li>PostgreSQL - at least version 12.</li> <li>Terraform &gt;= 1.2.0</li> <li>An SSL certificate.</li> </ul>"},{"location":"install/#download","title":"Download","text":"<p>There are three components that can be downloaded:</p> <ul> <li><code>otfd</code> - the server daemon</li> <li><code>otf</code> - the client CLI</li> <li><code>otf-agent</code> - the agent daemon</li> </ul> <p>Download them from Github releases.</p> <p>The server and agent components are also available as docker images:</p> <ul> <li><code>leg100/otfd</code></li> <li><code>leg100/otf-agent</code></li> </ul>"},{"location":"install/#quick-install","title":"Quick install","text":"<p>These steps will get you started with running the server on your local system.</p> <p>Download a release of the server component, <code>otfd</code>. The release is a zip file. Extract the <code>otfd</code> binary to your current directory.</p> <p>Ensure you have access to a postgres server. OTF by default assumes postgres is running locally, accessible via a domain socket in <code>/var/run/postgresql</code>, and defaults to using a database named <code>otf</code>. You need to create the database first:</p> <pre><code>createdb otf\n</code></pre> <p><code>otfd</code> requires a secret for creating cryptographic signatures. It should be up to 64 characters long and you should use a cryptographically secure random number generator, e.g.:</p> <pre><code>&gt; openssl rand -hex 32\n56789f6076a66323643f57a1016cdde7e7e39914785d36d61fdd8b9a30081f14\n</code></pre> <p>To get up and running quickly, we'll use the site admin account. This account has complete privileges and should only be used for administrative tasks rather than day-to-day usage. To use the account you need to set a token, which can any combination of characters. Make a note of this.</p> <p>Now start <code>otfd</code> with both the secret and the token:</p> <pre><code>&gt; ./otfd --secret=my-secret --site-token=my-token\n2022-10-30T20:06:10Z INF started cache max_size=0 ttl=10m0s\n2022-10-30T20:06:10Z INF successfully connected component=database path=postgres:///otf?host=/var/run/postgresql\n2022-10-30T20:06:10Z INF goose: no migrations to run. current version: 20221017170815 compone\nnt=database\n2022-10-30T20:06:10Z INF started server address=[::]:8080 ssl=false\n</code></pre> <p>You have now successfully installed <code>otfd</code> and confirmed you can start <code>otfd</code> with minimal configuration. Proceed to create your first organization.</p>"},{"location":"install/#create-organization","title":"Create organization","text":"<p>You can navigate to the web app in your browser:</p> <p>http://localhost:8080</p> <p>Note it announces you have 'no authenticators configured'. The normal method of login is to use SSO signin, via Github etc, but in this quickstart we're using the site admin account. Click on the 'site admin' link in the bottom right, and use your token to login.</p> <p>Go to 'organizations' and click <code>New Organization</code>. Give the organization a name and create.</p>"},{"location":"install/#run-terraform","title":"Run Terraform","text":"<p>Note</p> <p>The terraform CLI will be connecting to the server and it expects to make a verified SSL connection. Therefore we need to configure SSL first.</p> <p>Generate a self-signed SSL certificate and key:</p> <pre><code>openssl req -x509 -newkey rsa:4096 -sha256 -keyout key.pem -out cert.crt -days 365 -nodes -subj '/CN=localhost' -addext 'subjectAltName=DNS:localhost'\n</code></pre> <p>Ensure your system trusts the generated cert. For example, on Ubuntu based systems:</p> <pre><code>sudo cp cert.crt /usr/local/share/ca-certificates\nsudo update-ca-certificates\n</code></pre> <p>Now return to the terminal in which <code>otfd</code> is running. You'll need to kill it and start it again, this time with SSL enabled:</p> <pre><code>&gt; ./otfd --secret=my-secret --site-token=my-token --ssl --cert-file=cert.crt --key-file=key.pem\n</code></pre> <p>Terraform needs to use your token to authenticate with <code>otfd</code>:</p> <pre><code>terraform login localhost:8080\n</code></pre> <p>Enter <code>yes</code> to proceed.</p> <p>Bug</p> <p>You'll notice <code>terraform login</code> opens a browser window. However it ignores the port, thereby failing to open the correct page on the server. Once you properly deploy the server on a non-custom port this won't be a problem.</p> <p>Ignore the browser window it has opened and enter your token at the terminal prompt. You should receive confirmation of success:</p> <pre><code>Success! Logged in to Terraform Enterprise (localhost:8080)\n</code></pre> <p>Now we'll write some terraform configuration. Configure the terraform backend and define a resource:</p> <pre><code>cat &gt; main.tf &lt;&lt;EOF\nterraform {\n  backend \"remote\" {\n    hostname = \"localhost:8080\"\n    organization = \"default\"\n\n    workspaces {\n      name = \"dev\"\n    }\n  }\n}\n\nresource \"null_resource\" \"quickstart\" {}\nEOF\n</code></pre> <p>Initialize terraform:</p> <pre><code>terraform init\n</code></pre> <p>Run a plan:</p> <pre><code>terraform plan\n</code></pre> <p>That starts a run on the server. You can click on the link to the run to view status and logs.</p> <p>And apply:</p> <pre><code>terraform apply\n</code></pre> <p>This starts another run on the server. Again you can click on the link to see logs.</p> <p>You have reached the end of this quickstart guide. Have a look at the remainder of the documentation to further complete the installation of OTF, to setup SSO, run agents, etc.</p>"},{"location":"install/#install-from-source","title":"Install from source","text":"<p>You'll need Go.</p> <p>Clone the repo, then build and install using the make task:</p> <pre><code>git clone https://github.com/leg100/otf\ncd otf\nmake install\n</code></pre> <p>That'll install the binaries inside your go bin directory (defaults to <code>$HOME/go/bin</code>).</p>"},{"location":"install/#install-helm-chart","title":"Install helm chart","text":"<p>You can install the OTF server on Kubernetes using the helm chart.</p> <pre><code>helm repo add otf https://leg100.github.io/otf-charts\nhelm upgrade --install otf otf/otf\n</code></pre> <p>To see all configurable options with detailed comments:</p> <pre><code>helm show values otf/otf\n</code></pre> <p>Note</p> <p>The helm chart is maintained in a separate github repo.</p>"},{"location":"rbac/","title":"RBAC","text":"<p>The authorization model largely follows that of Terraform Cloud/Enterprise. An organization comprises a number of teams. A user is a member of one or more teams. Teams are assigned permissions permitting access to various functionality. Team permissions can be assigned at two levels: on organizations and on individual workspaces.</p>"},{"location":"rbac/#owners","title":"Owners","text":"<p>Every organization has an <code>owners</code> team. The user that creates an organization becomes its owner. The owners team must have at least one member and it cannot be deleted.</p> <p>Members of the owners team possess broad privileges across an organization. Owners are the only users permitted to alter organization-level permissions. They are also automatically assigned all the organization-level permissions; these permissions cannot be unassigned.</p>"},{"location":"rbac/#permissions","title":"Permissions","text":"<p>Permissions are assigned to teams on two levels: organizations and workspaces. Organization permissions confer privileges across the organization:</p> <ul> <li>Manage Workspaces: Allows members to create and administrate all workspaces within the organization.</li> <li>Manage VCS Settings: Allows members to manage the set of VCS providers available within the organization.</li> <li>Manage Registry: Allows members to publish and delete modules within the organization.</li> </ul> <p>Workspace permissions confer privileges on the workspace alone, and are based on the fixed permission sets of TFC/TFE:</p> <ul> <li>Read</li> <li>Plan</li> <li>Write</li> <li>Admin</li> </ul> <p>See the TFC/TFE documentation for more information on the privileges each permission set confers.</p>"},{"location":"rbac/#site-admins","title":"Site Admins","text":"<p>Site admins possesses supreme privileges across an OTF cluster. There are two ways to assume the role:</p> <ul> <li>Use a site token to login as the <code>site-admin</code> user</li> <li>Promote users to the role using the <code>--site-admins</code> flag</li> </ul>"},{"location":"registry/","title":"Module Registry","text":"<p>OTF includes a registry of terraform modules. You can publish modules to the registry from a git repository and source the modules in your terraform configuration.</p>"},{"location":"registry/#publish-module","title":"Publish module","text":"<p>To publish a module, go to the organization main menu, select 'modules' and click 'publish'.</p> <p>You then need to select a VCS provider. If none are visible you need to first create a provider.</p> <p>Connect to the provider and you are presented with a list of git repositories. Select the repository that contains the module you want to publish. If the repository is not visible you can enter its path instead.</p> <p>Note</p> <p>Only the first 100 repositories found on your provider are shown.</p> <p>Once you select a repository, you are asked to confirm your selection. OTF then retrieves the repository's git tags. For each tag that looks like a semantic version, e.g. <code>v1.0.0</code> or <code>0.10.3</code>, it'll download the contents of the repository for each tag and publish a module with that version. You should then be redirected to the module's page, containing information regarding its resources, inputs and outputs, along with usage instructions.</p> <p>Note</p> <p>Ensure your repository has at least one tag that looks like a semantic version. Otherwise OTF will fail to publish the module.</p> <p>A webhook is also added to the repository. Any tags pushed to the repository will trigger the webhook and new module versions will be published.</p>"},{"location":"vcs_providers/","title":"VCS Providers","text":"<p>To connect workspaces and modules to git repositories containing Terraform configurations, you need to provide OTF with access to your VCS provider.</p> <p>Firstly, create a provider for your organization. On your organization's main menu, select 'VCS providers'.</p> <p>You'll be presented with a choice of providers to create. The choice is restricted to those for which you have enabled SSO. For instance, if you have enabled Github SSO then you can create a Github VCS provider.</p> <p>Select the provider you would like to create. You will then be prompted to enter a personal access token. Instructions for generating the token are included on the page. The token permits OTF to access your git repository and retrieve terraform configuration. Once you've generated and inserted the token into the field you also need to give the provider a name that describes it.</p> <p>Note</p> <p>Be sure to restrict the permissions on the token according to the instructions.</p> <p>Create the provider and it'll appear on the list of providers. You can now proceed to connecting workspaces and publishing modules.</p>"},{"location":"vcs_providers/#connecting-a-workspace","title":"Connecting a workspace","text":"<p>Once you have a provider you can connect a workspace to a git repository for that provider.</p> <p>Select a workspace. Go to its 'settings' (in the top right of the workspace page).</p> <p>Click 'Connect to VCS'.</p> <p>Select the provider.</p> <p>You'll then be presented with a list of repositories. Select the repository containing the terraform configuration you want to use in your workspace. If you cannot see your repository you can enter its name.</p> <p>Once connected you can start a run via the web UI. On the workspace page select the 'start run' drop-down box and select an option to either start a plan or both a plan and an apply.</p> <p>That will start a run, retrieving the configuration from the repository, and you will see the progress of its plan and apply.</p>"},{"location":"auth/","title":"Authentication","text":"<p>OTF provides a variety of mechanisms for authenticating users and clients.</p>"},{"location":"auth/#identity-providers","title":"Identity Providers","text":"<p>Authentication of users to the web UI is delegated to an identity provider. Support currently exists for:</p> <ul> <li>Github OAuth</li> <li>Gitlab OAuth</li> <li>Google IAP</li> </ul>"},{"location":"auth/#site-admin","title":"Site Admin","text":"<p>The <code>site-admin</code> user allows for exceptional access to OTF. The user possesses unlimited privileges and uses a token to sign-in. See the documentation for the <code>--site-token</code> flag for details on how to set the token.</p> <p>Note</p> <p>Keep the token secure. Anyone with access to the token has complete access to OTF.</p> <p>You can sign into the web UI using the token. Use the link found in the bottom right corner of the login page.</p> <p>You can also configure the <code>otf</code> client CLI and the <code>terraform</code> CLI to use this token:</p> <pre><code>terraform login &lt;otf hostname&gt;\n</code></pre> <p>And enter the token when prompted. It'll be persisted to a local credentials file.</p> <p>Note</p> <p>Use of the site admin token is recommended only for one-off administrative and testing purposes. You should use an identity provider in most cases.</p>"},{"location":"auth/providers/github/","title":"Github","text":"<p>Configure OTF to sign users in using their Github account.</p> <p>Create an OAuth application in Github by following their step-by-step instructions.</p> <ul> <li>Set application name to something appropriate, e.g. <code>otf</code></li> <li>Set the homepage URL to the URL of your otfd installation (although this is purely informational).</li> <li>Set an optional description.</li> <li> <p>Set the authorization callback URL to:</p> <p><code>https://&lt;otf_hostname&gt;/oauth/github/callback</code></p> </li> </ul> <p>Note</p> <p>It is recommended that you first set the <code>--hostname</code> flag to a hostname that is accessible by Github, and that you use this hostname in the authorization callback URL above.</p> <p>Once you've registered the application, note the client ID and secret.</p> <p>Set the following flags when running <code>otfd</code>:</p> <pre><code>otfd --github-client-id=&lt;client_id&gt; --github-client-secret=&lt;client_secret&gt;\n</code></pre> <p>If you're using Github Enterprise you'll also need to inform <code>otfd</code> of its hostname:</p> <pre><code>otfd --github-hostname=&lt;hostname&gt;\n</code></pre> <p>Now when you start <code>otfd</code>, navigate to its URL in your browser and you'll be prompted to login with Github.</p> <p>Note</p> <p>In previous versions of OTF, Github organizations and teams were synchronised to OTF. This functionality was removed as it was deemed a security risk.</p>"},{"location":"auth/providers/gitlab/","title":"Gitlab","text":"<p>Configure OTF to sign users in using their Gitlab account.</p> <p>Create an OAuth application for your Gitlab group by following their step-by-step instructions.</p> <ul> <li>Set name to something appropriate, e.g. <code>otf</code></li> <li>Select <code>Confidential</code>.</li> <li>Select the <code>read_api</code> and <code>read_user</code> scopes.</li> <li> <p>Set the redirect URI to:</p> <p><code>https://&lt;otfd_install_hostname&gt;/oauth/gitlab/callback</code></p> </li> </ul> <p>Note</p> <p>It is recommended that you first set the <code>--hostname</code> flag to a hostname that is accessible by Gitlab, and that you use this hostname in the redirect URI above.</p> <p>Once you've created the application, note the Application ID and Secret.</p> <p>Set the following flags when running <code>otfd</code>:</p> <pre><code>otfd --gitlab-client-id=&lt;application_id&gt; --gitlab-client-secret=&lt;secret&gt;\n</code></pre> <p>If you're hosting your own Gitlab you'll also need to inform <code>otfd</code> of its hostname:</p> <pre><code>otfd --gitlab-hostname=&lt;hostname&gt;\n</code></pre> <p>Now when you start <code>otfd</code> navigate to its URL in your browser and you'll be prompted to login with Gitlab.</p> <p>Note</p> <p>In previous versions of OTF, Gitlab groups were synchronised to OTF. This functionality was removed as it was deemed a security risk.</p>"},{"location":"auth/providers/iap/","title":"Google IAP","text":"<p>OTF supports deployment using Google's Identity-Aware Proxy. Deploy an OTF cluster to Google Cloud (GCP) and enable IAP to authenticate users accessing the cluster. Only authenticated requests reach the cluster and each request contains information about the user. OTF verifies the requests and checks the user exists. If the user does not exist an account is created.</p> <p> IAP deployment with GCP Compute Engine / GKE (image sourced from Google Cloud documentation)</p>"},{"location":"auth/providers/iap/#verification","title":"Verification","text":"<p>OTF checks each incoming request for the presence of a signed IAP header. If present then it verifies the header's signed token to verify it originated from Google IAP and that it has not expired.</p> <p>You can also configure OTF to validate the audience token claim. Validating the audience checks OTF is indeed the intended recipient of the request. Follow Google's instructions for retrieving the audience string. Then set the --iap-google-jwt-audience <code>otfd</code> flag accordingly, e.g.:</p> <pre><code>otfd --google-jwt-audience /projects/project_number/apps/my_project_id\n</code></pre> <p>It is recommended you set this flag, especially for a production deployment.</p>"},{"location":"auth/providers/iap/#authentication","title":"Authentication","text":"<p>Authentication is delegated to IAP. From the Google Cloud documentation:</p> <p>...IAP checks the user's browser credentials. If none exist, the user is redirected to an OAuth 2.0 Google Account sign-in flow that stores a token in a browser cookie for future sign-ins... ...If the request credentials are valid, the authentication server uses those credentials to get the user's identity (email address and user ID). The authentication server then uses the identity to check the user's IAM role and check if the user is authorized to access the resource.</p>"},{"location":"auth/providers/iap/#authorization","title":"Authorization","text":"<p>IAP permits restricting which users can access the cluster (ibid):</p> <p>After authentication, IAP applies the relevant IAM policy to check if the user is authorized to access the requested resource. If the user has the IAP-secured Web App User role on the Google Cloud console project where the resource exists, they're authorized to access the application</p> <p>Whereas OTF remains responsible for determining what users can access, i.e. you assign users to teams and set team permissions to allow access to organizations and workspaces, etc.</p>"},{"location":"config/envvars/","title":"Environment variables","text":"<p>OTF can be configured from environment variables. Arguments can be converted to the equivalent env var by prefixing it with <code>OTF_</code>, replacing all <code>-</code> with <code>_</code>, and upper-casing it. For example:</p> <ul> <li><code>--secret</code> becomes <code>OTF_SECRET</code></li> <li><code>--site-token</code> becomes <code>OTF_SITE_TOKEN</code></li> </ul> <p>Env variables can be suffixed with <code>_FILE</code> to tell OTF to read the values from a file. This is useful for container environments where secrets are often mounted as files.</p>"},{"location":"config/flags/","title":"Flags","text":""},{"location":"config/flags/#-address","title":"<code>--address</code>","text":"<ul> <li>System: <code>otfd</code>, <code>otf-agent</code></li> <li>Default: <code>localhost:8080</code></li> </ul> <p>Sets the listening address of an <code>otfd</code> node.</p> <p>Set the port to an empty string or to <code>0</code> to choose a random available port.</p> <p>Set the address to an empty string to listen on all interfaces. For example, the following listens on all interfaces using a random port:</p> <pre><code>otfd --address :0\n</code></pre>"},{"location":"config/flags/#-cache-expiry","title":"<code>--cache-expiry</code>","text":"<ul> <li>System: <code>otfd</code></li> <li>Default: <code>10 minutes</code></li> </ul> <p>Set the TTL for cache entries.</p>"},{"location":"config/flags/#-cache-size","title":"<code>--cache-size</code>","text":"<ul> <li>System: <code>otfd</code></li> <li>Default: <code>0</code> (unlimited)</li> </ul> <p>Cache size in MB. The cache is stored in RAM. Default is <code>0</code> which means it'll use an unlimited amount of RAM.</p> <p>It is recommended that you set this to an appropriate size in a production deployment, taking into consideration the cache expiry.</p>"},{"location":"config/flags/#-concurrency","title":"<code>--concurrency</code>","text":"<ul> <li>System: <code>otfd</code>, <code>otf-agent</code></li> <li>Default: 5</li> </ul> <p>Sets the number of workers that can process runs concurrently.</p>"},{"location":"config/flags/#-google-jwt-audience","title":"<code>--google-jwt-audience</code>","text":"<ul> <li>System: <code>otfd</code></li> <li>Default: \"\"</li> </ul> <p>The Google JWT audience claim for validation. If unspecified then the audience claim is not validated. See the Google IAP document for more details.</p>"},{"location":"config/flags/#-hostname","title":"<code>--hostname</code>","text":"<ul> <li>System: <code>otfd</code></li> <li>Default: <code>localhost:8080</code> or <code>--address</code> if specified.</li> </ul> <p>Sets the hostname that clients can use to access the OTF cluster. This value is used within links sent to various clients, including:</p> <ul> <li>The <code>terraform</code> CLI when it is streaming logs for a remote <code>plan</code> or <code>apply</code>.</li> <li>Pull requests on VCS providers, e.g. the link beside the status check on a Github pull request.</li> </ul> <p>It is highly advisable to set this flag in a production deployment.</p>"},{"location":"config/flags/#-log-format","title":"<code>--log-format</code>","text":"<ul> <li>System: <code>otfd</code>, <code>otf-agent</code></li> <li>Default: <code>default</code></li> </ul> <p>Set the logging format. Can be one of:</p> <ul> <li><code>default</code>: human-friendly, not easy to parse, writes to stderr</li> <li><code>text</code>: sequence of key=value pairs, writes to stdout</li> <li><code>json</code>: json format, writes to stdout</li> </ul>"},{"location":"config/flags/#-plugin-cache","title":"<code>--plugin-cache</code>","text":"<ul> <li>System: <code>otfd</code>, <code>otf-agent</code></li> <li>Default: disabled</li> </ul> <p>Enable the terraform plugin cache.</p> <p>Each plan and apply starts afresh without any provider plugins. They first invoke <code>terraform init</code>, which downloads plugins from registries. Given that plugins can be quite large this can use a lot of bandwidth. The terraform plugin cache avoids this by caching plugins in a shared directory.</p> <p>However, enabling the cache causes a known issue. If the user is on a different platform to that running OTF, e.g. the user is on a Mac but <code>otfd</code> is running on Linux, then you might see an error similar to the following:</p> <pre><code>Error: Failed to install provider from shared cache\n\nError while importing hashicorp/null v3.2.1 from the shared cache\ndirectory: the provider cache at .terraform/providers has a copy of\nregistry.terraform.io/hashicorp/null 3.2.1 that doesn't match any of the\nchecksums recorded in the dependency lock file.\n</code></pre> <p>The workaround is for users to include checksums for OTF's platform in the lock file too, e.g. if <code>otfd</code> is running on Linux on amd64 then they would run the following:</p> <pre><code>terraform providers lock -platform=linux_amd64\n</code></pre> <p>That'll update <code>.terraform.lock.hcl</code> accordingly. This command should be invoked whenever a change is made to the providers and their versions in the configuration.</p> <p>Note</p> <p>Another alternative is to configure OTF to use an HTTPS caching proxy.</p>"},{"location":"config/flags/#-restrict-org-creation","title":"<code>--restrict-org-creation</code>","text":"<ul> <li>System: <code>otfd</code></li> <li>Default: false</li> </ul> <p>Restricts the ability to create organizations to users possessing the site admin role. By default any user can create organizations.</p> <pre><code>otfd --site-admins bob@example.com,alice@example.com\n</code></pre> <p>The users must exist on the system. Any users that were previously promoted and are no longer specified with this flag are demoted.</p>"},{"location":"config/flags/#-site-admins","title":"<code>--site-admins</code>","text":"<ul> <li>System: <code>otfd</code></li> <li>Default: []</li> </ul> <p>Promote users to the role of site admin. Specify their usernames, separated by a comma. For example:</p> <pre><code>otfd --site-admins bob@example.com,alice@example.com\n</code></pre> <p>The users must exist on the system. Any users that were previously promoted and are no longer specified with this flag are demoted.</p>"},{"location":"config/flags/#-site-token","title":"<code>--site-token</code>","text":"<ul> <li>System: <code>otfd</code></li> <li>Default: \"\"</li> </ul> <p>Set a site token for authenticating with the <code>site-admin</code> user, e.g.:</p> <pre><code>otfd --site-token=643f57a1016cdde7e7e39914785d36d61fd\n</code></pre> <p>The token cannot be longer than 64 characters and you should use a cryptographically secure random number generator, for example using <code>openssl</code>:</p> <pre><code>openssl rand -hex 32\n</code></pre> <p>The default or an empty string disables use of a site token.</p>"},{"location":"config/flags/#-v-v","title":"<code>--v</code>, <code>-v</code>","text":"<ul> <li>System: <code>otfd</code>, <code>otf-agent</code></li> <li>Default: <code>0</code></li> </ul> <p>Set logging verbosity. The higher the number the more verbose the logs. Each number translates to a <code>level</code> log field like so:</p> verbosity level 0 INFO 1 DEBUG 2 DEBUG-1 3 DEBUG-2 n DEBUG-(n+1)"}]}